
## Algorithm

1. **State Structure**
   Each state represents a position `(x, y)` in the grid with the following attributes:~  
   - `x, y` → coordinates of the state  
   - `g` → cost from start to this node  
   - `h` → heuristic cost to goal  
   - `f` → evaluation function `f = g + h`  
   - `solved` → boolean flag if goal is reached  
   - `isAndNode` → marker for AND nodes  
   - `children` → vector of successor states  

2. **Heuristic Function**
   The heuristic used is Manhattan distance between the current state and the goal:~  
   \[
   h(n) = |x_{current} - x_{goal}| + |y_{current} - y_{goal}|
   \]  

3. **Successor Generation**
   For a given state `(x, y)`, valid successors are generated by moving in four directions (Up, Down, Left, Right), provided the new coordinates are within grid bounds.~  

4. **AO\* Search**
   - Recursively apply AO\* on child nodes.  
   - For each node:  
     - If no successors → assign large cost.  
     - Otherwise, compute the cost of the best child.  
   - Mark a state as solved if it matches the goal.  

5. **Final Evaluation**
   The algorithm computes the final cost from start to goal and displays it.~  

---

## Time Complexity
- **Worst-case time complexity:**  
  \[
  O(b^d)
  \]  
  where \(b\) = branching factor and \(d\) = depth of solution.~  

---

## Space Complexity
~AO\* requires storing explored states, hence~  
\[
O(bd)
\]  

---

## Use Cases
- Solving **AND-OR search problems** in AI.  
- Game playing strategies.  
- Planning problems where states can be decomposed into subproblems.  

---

## <u>AIM</u>
To solve a grid-based search problem using the **Alpha-Beta Pruning** algorithm.  

---

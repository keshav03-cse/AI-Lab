# Tic Tac Toe using MinMax Algorithm  

## Aim  
The aim of this project is to implement a **Tic Tac Toe game** where the user competes against the computer. The computer uses the **MinMax algorithm** to make optimal moves, ensuring it never loses.  

---

## Data Structures Used  
- **Vector (`vector<char>`)**:  
  - Used to represent the 3x3 game board.  
  - Each cell can contain `'X'` (user), `'O'` (AI), or `' '` (empty).  

- **2D Array (`int wins[8][3]`)**:  
  - Stores all possible winning positions (rows, columns, diagonals).  

- **Constants**:  
  - `USER = 'X'` ‚Üí Player symbol.  
  - `AI = 'O'` ‚Üí Computer symbol.  
  - `EMPTY = ' '` ‚Üí Empty cell.  

---

## Algorithm (MinMax)  
The **MinMax algorithm** is used to choose the best move for the AI:  

1. **Base Cases**:  
   - If the board has a winner ‚Üí return `+1` (User win) or `-1` (AI win).  
   - If no moves left ‚Üí return `0` (Draw).  

2. **Recursive Case**:  
   - If it‚Äôs AI‚Äôs turn: choose the move with the **minimum score** (since AI tries to minimize the user‚Äôs winning chances).  
   - If it‚Äôs User‚Äôs turn: choose the move with the **maximum score** (user tries to maximize their win chance).  

3. The **best move** is selected in `findMove()` by simulating all possible moves and picking the one with the minimum outcome score.  

---

## State Generation  
Each possible game state is generated by:  
- Iterating over all empty positions.  
- Making a move in that position.  
- Recursively applying the MinMax function to simulate future moves.  
- Undoing the move (backtracking).  

This way, the entire **game tree** of possible moves is explored.  

---

## Utility Functions  
- **`printBoard(board)`** ‚Üí Displays the current board in a 3x3 grid.  
- **`checkWinner(board)`** ‚Üí Checks if a player has won.  
- **`movesLeft(board)`** ‚Üí Checks if there are empty spaces left.  
- **`MinMax(board, playerAI)`** ‚Üí Implements the recursive MinMax logic.  
- **`findMove(board)`** ‚Üí Finds the optimal AI move based on MinMax evaluation.  

---

## Use Cases  
- Learning how the **MinMax algorithm** works in game theory.  
- Practicing **recursion and backtracking** in C++.  
- Demonstrating an **unbeatable Tic Tac Toe AI**.  
- Useful in **AI coursework, projects, and assignments**.  

---

## Time Complexity  
- At most **9! ‚âà 362,880** states (all possible game trees).  
- In practice, the complexity is reduced because the game ends early.  
- **Worst-case Time Complexity**: **O(b^d)**, where  
  - `b = branching factor (‚â§ 9)`  
  - `d = depth of the game tree (‚â§ 9)`  

So, roughly **O(9!) = O(362,880)**.  

---

## Space Complexity  
- The recursion stack can go as deep as the number of moves (9).  
- Each board state uses **O(9) = O(1)** space.  
- **Total Space Complexity**: **O(d) = O(9) = O(1)** (constant space).  

---

## üñ•Ô∏è Sample Output  
```text
Tic Tac Toe (User=X, Computer=O)

Board:
 1 | 2 | 3
---+---+---
 4 | 5 | 6
---+---+---
 7 | 8 | 9

Enter your move(1-9):5

Board:
 1 | 2 | 3
---+---+---
 4 | X | 6
---+---+---
 7 | 8 | 9

Computer chooses position 1

Board:
 0 | 2 | 3
---+---+---
 4 | X | 6
---+---+---
 7 | 8 | 9

Enter your move(1-9):8

Board:
 0 | 2 | 3
---+---+---
 4 | X | 6
---+---+---
 7 | X | 9

Computer chooses position 2

Board:
 0 | 0 | 3
---+---+---
 4 | X | 6
---+---+---
 7 | X | 9

Enter your move(1-9):3

Board:
 0 | 0 | X
---+---+---
 4 | X | 6
---+---+---
 7 | X | 9

Computer chooses position 7

Board:
 0 | 0 | X
---+---+---
 4 | X | 6
---+---+---
 0 | X | 9

Enter your move(1-9):4

Board:
 0 | 0 | X
---+---+---
 X | X | 6
---+---+---
 0 | X | 9

Computer chooses position 6

Board:
 0 | 0 | X
---+---+---
 X | X | 0
---+---+---
 0 | X | 9

Enter your move(1-9):9

Board:
 0 | 0 | X
---+---+---
 X | X | 0
---+---+---
 0 | X | X

It's a Draw!
```
## Advantages  
- Guarantees an **optimal strategy**: the AI will never lose.  
- Explores all possible game states, ensuring no winning possibility is missed.  
- Works for any **two-player zero-sum game** with finite states (e.g., Tic Tac Toe, Connect Four).  
- Simple to understand and implement using recursion and backtracking.  

---

## Limitations  
- **Exponential time complexity**: grows as **O(b^d)** where `b` = branching factor and `d` = depth of the game tree.  
- Impractical for **complex games** like Chess or Go (too many possible states).  
- Requires **significant computation** even for moderately large state spaces.  
- No learning ability ‚Üí purely rule-based, does not improve over time.  
- Without **optimizations like Alpha-Beta Pruning**, it explores unnecessary states. 
